package com.todaii.english.server.vocabulary;

import java.util.*;
import java.util.stream.Collectors;

import org.modelmapper.ModelMapper;
import org.springframework.stereotype.Service;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.todaii.english.core.entity.DictionaryEntry;
import com.todaii.english.core.entity.DictionarySense;
import com.todaii.english.core.entity.VocabDeck;
import com.todaii.english.core.port.GeminiPort;
import com.todaii.english.server.dictionary.DictionaryEntryRepository;
import com.todaii.english.server.dictionary.DictionaryEntryService;
import com.todaii.english.shared.constants.Gemini;
import com.todaii.english.shared.dto.DictionaryEntryDTO;
import com.todaii.english.shared.exceptions.BusinessException;
import com.todaii.english.shared.response.DictionaryApiResponse;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Service
@RequiredArgsConstructor
public class VocabDeckGeneratorService {

	private final VocabDeckRepository vocabDeckRepository;
	private final DictionaryEntryService dictionaryEntryService;
	private final DictionaryEntryRepository dictionaryEntryRepository;
	private final GeminiPort geminiPort;
	private final ObjectMapper objectMapper;
	private final ModelMapper modelMapper;

	/**
	 * Tự động sinh danh sách từ cho một deck nhất định
	 */
	public VocabDeck autoGenerateDeckWords(Long deckId, Long quantity) {
		// Lấy deck từ DB
		VocabDeck deck = vocabDeckRepository.findById(deckId)
				.orElseThrow(() -> new BusinessException(404, "Deck not found"));

		// Sinh danh sách từ gợi ý bằng Gemini
		List<String> suggestedWords = createSuggestedWords(deck, quantity);

		// Chuẩn hóa danh sách từ (lowercase + trim)
		Set<String> wordSet = suggestedWords.stream().map(String::trim).map(String::toLowerCase)
				.collect(Collectors.toSet());

		// Lấy các từ đã có trong DB (dựa theo headword)
		List<DictionaryEntry> existingEntries = wordSet.stream()
				.flatMap(word -> dictionaryEntryRepository.findByHeadwordContainingIgnoreCase(word).stream()).distinct()
				.collect(Collectors.toList());

		Set<DictionaryEntry> finalWords = new HashSet<>(existingEntries);

		// Nếu đã đủ số lượng → trả về luôn
		if (finalWords.size() >= quantity) {
			deck.setWords(finalWords.stream().limit(quantity).collect(Collectors.toSet()));
			return deck;
		}

		// Xác định các từ chưa có trong DB
		Set<String> existingHeadwords = existingEntries.stream().map(e -> e.getHeadword().toLowerCase())
				.collect(Collectors.toSet());

		List<String> missingWords = wordSet.stream().filter(word -> !existingHeadwords.contains(word)).toList();

		// Nếu không còn từ thiếu → kết thúc
		if (missingWords.isEmpty()) {
			deck.setWords(finalWords);
			return deck;
		}

		// Lấy dữ liệu thô từ Dictionary API và refine bằng Gemini
		handleMissingWords(missingWords, finalWords);

		// Giới hạn số lượng từ cuối cùng theo yêu cầu
		deck.setWords(finalWords.stream().limit(quantity).collect(Collectors.toSet()));
		return deck;
	}

	/**
	 * Tạo danh sách từ gợi ý từ Gemini theo deck
	 */
	private List<String> createSuggestedWords(VocabDeck deck, Long quantity) {
		String prompt = buildDeckPrompt(deck, quantity);
		String rawResponse = geminiPort.generateText(prompt);
		return parseWordList(rawResponse);
	}

	/**
	 * Xây dựng prompt để Gemini sinh từ vựng phù hợp
	 */
	private String buildDeckPrompt(VocabDeck deck, Long quantity) {
		return String.format(Gemini.DECK_WORDS_PROMPT, quantity, deck.getCefrLevel(), deck.getName(),
				deck.getDescription());
	}

	/**
	 * Gọi Dictionary API cho các từ thiếu, refine với Gemini và thêm vào finalWords
	 */
	private void handleMissingWords(List<String> missingWords, Set<DictionaryEntry> finalWords) {
		try {
			List<DictionaryApiResponse[]> rawApiResponses = new ArrayList<>();

			for (String word : missingWords) {
				try {
					DictionaryApiResponse[] response = dictionaryEntryService.lookupWord(word);
					if (response != null && response.length > 0) {
						rawApiResponses.add(response);
					}
				} catch (Exception e) {
					log.warn("❗ Lỗi khi gọi Dictionary API cho '{}': {}", word, e.getMessage());
				}
			}

			// Nếu không có dữ liệu nào trả về
			if (rawApiResponses.isEmpty()) {
				log.info("Không có từ nào được lấy từ Dictionary API.");
				return;
			}

			// Gom dữ liệu thô thành JSON để refine hàng loạt
			String rawJson = objectMapper.writeValueAsString(rawApiResponses);
			String refinePrompt = String.format(Gemini.DICTIONARY_PROMPT, rawJson, String.join(", ", missingWords));

			// Gọi Gemini refine dữ liệu
			String refinedResponse = geminiPort.generateText(refinePrompt);
			List<DictionaryEntry> refinedEntries = parseDictionaryBatch(refinedResponse);

			// Lưu DB và thêm vào final set
			if (!refinedEntries.isEmpty()) {
				dictionaryEntryRepository.saveAll(refinedEntries);
				finalWords.addAll(refinedEntries);
			}

		} catch (Exception e) {
			log.error("❌ Lỗi khi lấy hoặc refine từ Dictionary API: {}", e.getMessage(), e);
		}
	}

	/**
	 * Chuyển response JSON của Gemini thành danh sách DictionaryEntry
	 */
	private List<DictionaryEntry> parseDictionaryBatch(String rawResponse) {
		try {
			DictionaryEntryDTO[] dtoArray = objectMapper.readValue(rawResponse, DictionaryEntryDTO[].class);
			return Arrays.stream(dtoArray).map(this::toEntity).collect(Collectors.toList());
		} catch (Exception e) {
			throw new BusinessException(500, "Invalid Gemini batch response format");
		}
	}

	/**
	 * Chuyển DTO → Entity và lưu sense
	 */
	public DictionaryEntry toEntity(DictionaryEntryDTO dto) {
		DictionaryEntry entry = DictionaryEntry.builder().headword(dto.getHeadword()).ipa(dto.getIpa())
				.audioUrl(dto.getAudioUrl()).build();

		entry.setSenses(buildSenses(dto, entry));

		return dictionaryEntryRepository.save(entry);
	}

	/**
	 * Tạo danh sách các DictionarySense từ DTO
	 */
	private Set<DictionarySense> buildSenses(DictionaryEntryDTO dto, DictionaryEntry entry) {
		return dto.getSenses().stream().map(s -> {
			DictionarySense sense = modelMapper.map(s, DictionarySense.class);
			sense.setEntry(entry);
			return sense;
		}).collect(Collectors.toSet());
	}

	/**
	 * Parse danh sách từ dạng JSON → List<String>
	 */
	private List<String> parseWordList(String rawResponse) {
		try {
			return Arrays.asList(objectMapper.readValue(rawResponse, String[].class));
		} catch (Exception e) {
			throw new BusinessException(500, "Invalid Gemini response format");
		}
	}
}
