package com.todaii.english.server.vocabulary;

import java.util.*;
import java.util.stream.Collectors;

import org.springframework.stereotype.Service;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.todaii.english.core.entity.DictionaryEntry;
import com.todaii.english.core.entity.VocabDeck;
import com.todaii.english.core.port.GeminiPort;
import com.todaii.english.server.dictionary.DictionaryEntryRepository;
import com.todaii.english.server.dictionary.DictionaryEntryService;
import com.todaii.english.shared.constants.Gemini;
import com.todaii.english.shared.dto.DictionaryEntryDTO;
import com.todaii.english.shared.exceptions.BusinessException;
import com.todaii.english.shared.response.DictionaryApiResponse;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Service
@RequiredArgsConstructor
public class VocabDeckGeneratorService {
	private final VocabDeckRepository vocabDeckRepository;
	private final DictionaryEntryService dictionaryEntryService;
	private final DictionaryEntryRepository dictionaryEntryRepository;
	private final GeminiPort geminiPort;
	private final ObjectMapper objectMapper;

	public VocabDeck autoGenerateDeckWords(Long deckId, Long quantity) {
		VocabDeck deck = vocabDeckRepository.findById(deckId)
				.orElseThrow(() -> new BusinessException(404, "Deck not found"));

		// Sinh danh sách từ gợi ý bằng Gemini, sau đó chuẩn hóa (trim + lowercase)
		Set<String> wordSet = createSuggestedWords(deck, quantity).stream().map(String::trim).map(String::toLowerCase)
				.collect(Collectors.toSet());

		/*
		 * Lấy các từ đã có trong DB (dựa theo headword), nếu > quantity yêu cầu thì
		 * return luôn
		 */
		List<DictionaryEntry> existingEntries = dictionaryEntryRepository.findByHeadwordInIgnoreCase(wordSet);
		Set<DictionaryEntry> finalWords = new HashSet<>(existingEntries);
		deck.setWords(finalWords);
		if (finalWords.size() >= quantity) {
			return deck;
		}

		// Xác định các từ chưa có trong DB, nếu ko còn từ thiếu thì return luôn
		Set<String> existingHeadwords = existingEntries.stream().map(e -> e.getHeadword().toLowerCase())
				.collect(Collectors.toSet());
		Set<String> missingWords = wordSet.stream().filter(word -> !existingHeadwords.contains(word))
				.collect(Collectors.toSet());
		if (missingWords.isEmpty()) {
			deck.setWords(finalWords);
			return deck;
		}

		// Lấy dữ liệu thô từ Dictionary API và refine bằng Gemini
		handleMissingWords(deck, missingWords, finalWords);

		return deck;
	}

	private Set<String> createSuggestedWords(VocabDeck deck, Long quantity) {
		String prompt = buildDeckPrompt(deck, quantity);
		String rawResponse = geminiPort.generateText(prompt);
		return parseWordSet(rawResponse);
	}

	// Xây dựng prompt để Gemini sinh từ vựng phù hợp
	private String buildDeckPrompt(VocabDeck deck, Long quantity) {
		return String.format(Gemini.DECK_WORDS_PROMPT, quantity, deck.getCefrLevel(), deck.getName(),
				deck.getDescription());
	}

	// Parse danh sách từ dạng JSON sang Set<String>
	private Set<String> parseWordSet(String rawResponse) {
		try {
			String[] words = objectMapper.readValue(rawResponse, String[].class);
			return new HashSet<>(Arrays.asList(words));
		} catch (Exception e) {
			throw new BusinessException(500, "Invalid Gemini response format");
		}
	}

	// Gọi Dictionary API cho các từ thiếu, refine với Gemini và thêm vào finalWords
	private void handleMissingWords(VocabDeck deck, Set<String> missingWords, Set<DictionaryEntry> finalWords) {
		try {
			List<DictionaryApiResponse[]> rawApiResponses = new ArrayList<>();

			for (String word : missingWords) {
				try {
					DictionaryApiResponse[] response = dictionaryEntryService.lookupWord(word);
					if (response != null && response.length > 0) {
						rawApiResponses.add(response);
					}
				} catch (Exception e) {
					log.warn("Lỗi khi gọi Dictionary API cho '{}': {}", word, e.getMessage());
				}
			}

			// Nếu không có dữ liệu nào trả về
			if (rawApiResponses.isEmpty()) {
				log.info("Không có từ nào được lấy từ Dictionary API.");
				return;
			}

			// Gom dữ liệu thô thành JSON để refine hàng loạt
			String rawJson = objectMapper.writeValueAsString(rawApiResponses);
			String refinePrompt = String.format(Gemini.DICTIONARY_PROMPT, rawJson, String.join(", ", missingWords));

			// Gọi Gemini refine dữ liệu
			String refinedResponse = geminiPort.generateText(refinePrompt);
			Set<DictionaryEntry> refinedEntries = parseDictionaryBatch(refinedResponse);

			if (deck.getWords() == null || deck.getWords().isEmpty()) {
				deck.setWords(new HashSet<>(refinedEntries));
			} else {
				deck.getWords().addAll(refinedEntries);
			}

			// Lưu DB và thêm vào final set
			if (!refinedEntries.isEmpty()) {
				finalWords.addAll(refinedEntries);
			}

		} catch (Exception e) {
			log.error("Lỗi khi lấy hoặc refine từ Dictionary API: {}", e.getMessage(), e);
		}
	}

	// Chuyển response JSON của Gemini thành danh sách DictionaryEntry
	private Set<DictionaryEntry> parseDictionaryBatch(String rawResponse) {
		try {
			DictionaryEntryDTO[] dtoArray = objectMapper.readValue(rawResponse, DictionaryEntryDTO[].class);
			return Arrays.stream(dtoArray).map(dictionaryEntryService::toEntity).collect(Collectors.toSet());
		} catch (Exception e) {
			throw new BusinessException(500, "Invalid Gemini batch response format");
		}
	}

}
